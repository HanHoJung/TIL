# Chapter05 재귀 알고리즘

[TOC]

## STORY 05-1 재귀의 기본

> 재귀란

- 어떤 사건이, **자기 자신을 포함**하고 **다시 자기 자신을 사용하여 정의** 될 때 재귀적(recursive)이라고 정의한다.

  ex)

  1은 자연수 입니다.

  자연수 n의 바로 다음 수도 자연수 이다.

> 재귀 호출이란

- "**자기 자신과 똑같은 함수**"를 호출하는 것

  > 직접 재귀(direct)=>자신과 같은 함수를 호출하는 것
  >
  > ```c++
  > void a(void){
  >     a();
  > }
  > ```
  >
  >
  >
  > 간접재귀(indirect)=>다른 함수를 통해 자기 자신과 같은 함수가 호출됨
  >
  > ```c++
  > void a(){
  >     b();
  > }
  > 
  > void b(){
  >     a()
  > }
  > ```
  >
  >

- 유클리드 호제법

  ```c++
  #include <iostream>
  using namespace std;
  int GCD(int a, int b) {
  	int val;
  	if (b == 0) {
  		return a;
  	}
  	return val = GCD(b, a%b);
  
  }
  
  int main(void) {
  	int a, b;
  	cin >> a >> b;
  
  	cout<<GCD(a, b);
  
  }
  
  /*
  22*8
  1. 짧은 변의 길이를 한 변으로 하는 정사각형으로 채움(8*8)
  2. 정사각형으로 나누어 떨어지는 것이 아닌 기준으로 또 정사각형으로 나눔
  3. 모든 사각형이 정하각형으로 구성되면 그 변의 길이가 최대공약수
  */
  
  ```

> Dynamic Programing(DP)

동적계획법

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘

- 분할 정복과 공통적은 큰 문제를 작은문제로 나눠서 푼다는 점이 공통점이지만, 분할 정복은 memoization이 필요하지 않는것이 차이가 있다.

> Memoization

   저장된 결과를 배열에 저장한 뒤, 다음에 계산이 필요한 때는 저장한 값을 불러와서 중복을 없애므로 시간 복잡도  

   가 줄어든다. 이러한 방법을 Memoization이라 한다.

  >  Top down(하향식 분석)

-  위에서 아래로 내려오는 방식
-  가독성이 좋고, 점화식을 이해하기 쉽다.

  > Bottom up(상향식 분석)

- for문을 이용해서 처음값부터 다음값을 계산해 나가는 방식
- 함수를 별도로 호출하지 않아 시간과 메모리를 절약할 수 있다.