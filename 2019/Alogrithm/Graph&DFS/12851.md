# 숨박꼭질2

> **문제분류:그래프와 bfs**
>
> **문제번호:12851**

> solution 1.
>
> 문제의 크기:  N(0 ≤ N ≤ 100,000), K(0 ≤ K ≤ 100,000)
> 문제 조건: 
> 제한시간:2초
>
> 이 문제는 수빈의 위치 N에서 3가지 연산(+1, -1, *2)을 통하여 최단 시간안에 동생의 위치에 도달하는 
>
> 시간을 찾는 문제입니다. BFS를 통하여 문제를 해결할 수 있습니다.
>
>
>
> **1.최소비용 문제이어야 한다.**
>
> 가장 빠른 시간(최소 비용)
>
>
>
> **2.간선의 가중치가 1이어야 한다.**
>
> 수빈의 위치를 정점으로 볼 수 있고, 
>
> 3가지 연산을 통하여 이동한 점의 연결이 간선이라고 생각할 수 있습니다.
>
> +1
>
> -1
>
> *2
>
> 3가지 연산 모두 1초의 시간이 걸리기 때문에 가중치가 1이라고 생각할 수 있습니다.
>
>
>
> **3.정점과 간선의 개수가 작아야 한다.**
>
> 100,000
>
> 10만개 정도면 BFS로 최소비용을 구할 수 있습니다.
>
>
>
> 한 정점에서, 3개의 연산에 대하여 이동탐색을 하고 다음 방향에 대하여 가중치에 1을 더하는 방식을 통해
>
> 최소 시간을 구할 수 있습니다. 그러나 이 문제에서는 가장 빠른 시간으로 방법이 몇 가지인지 까지 구하는 문제 입니다.
>
> 4->5->10 
>
> 8->9->10
>
> 가중치가 2안에 10으로 갈 수 있는 방법이 2가지 있습니다. 그러나 bfs 탐색으로는 10을 한 번 방문했으면 다음에는 next node가 10인 갯수를 queue에 넣지 않으므로 경우의 수를 셀 수 없습니다.
>
> 때문에, 이렇때는 다이나믹을 이용해야 합니다. 
>
> dp[i]//i까지 가는데 방법의 수
>
> 만약, next node를 방문하지 않았으면  dp[next_node]=dp[node];
>
> ​         next node를 방문했으면  dp[next_node]=dp[node]+dp[next_node];
>
> 가 됩니다. 그러나 여기서 주의할 점은 next node를 방문했을 때 조건이 하나 추가됩니다. 우리가 구할려고 하는 것은 가장 빠른 시간으로  가는 방법의 수를 찾는것입니다. 때문에 현재 node 가중치 +1 ==next node 가중치와 같아야 합니다. 

https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/Graph%26BFS/12851.cpp












