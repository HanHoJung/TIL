# 로봇 청소기

> **문제분류:Simulation**
>
> **문제번호:14503**

> solution 1.
>
> 문제의 크기: 가로 N,M(3 ≤ N, M ≤ 50)
>
> 시간제한: 2초
>
> 
>
> 로봇 청소기 문제는 청소기가 이동하면서 청소하는 칸을 구하는 문제 입니다.
>
> 다음과 같은 조건이 존재합니다.
>
> - 청소 영역(N*M)
>   - 0: 청소 되어 있지 않는 상태
>   - 1:벽
>   - 2:청소 되어 있는 상태
> - 로봇 청소기 동작
>   1. 현재 위치를 청소한다.
>   2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
>      1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
>      2. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
>      3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
>      4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
>
> 이 문제에서 주의할 점은 왼쪽 방향으로 탐색을 진행한다는 점 입니다.
>
>    0:북->서->남->동(0->3->2->1)
>    1:동->북->서->남(1->0->3->2)
>    2:남->동->북->서(2->1->0->3)
>    3:서->남->동->북(3->2->1->0)
>
> 따라서 이것을 일반화 시키면 dir이 방향이라고 했을 때 다음 왼쪽 방향은
>
> dir = (dir+3)%4 이러한 식이 도출 됩니다.
>
> 코드를 살펴보면
>
> ```c++
> #include <iostream>
> #include <vector>
> using namespace std;
> /*북,동,남,서(왼쪽방향)*/
> int dx[] = { -1,0,1,0 };//
> int dy[] = { 0,1,0,-1 };
> 
> 
> /*
>    0:북->서->남->동(0->3->2->1)
>    1:동->북->서->남(1->0->3->2)
>    2:남->동->북->서(2->1->0->3)
>    3:서->남->동->북(3->2->1->0)
> */
> int main(void) {
> 	int n, m;
> 	cin >> n >> m;
> 	vector<vector<int>> MAP(n, vector<int>(m));
> 
> 	int x, y, dir;
> 
> 	cin >> x >> y >> dir;
> 
> 
> 	for (int i = 0; i < n; i++) {
> 		for (int j = 0; j < m; j++) {
> 			cin >> MAP[i][j];
> 		}
> 	}
> 
> 	/*
> 	   0:청소x
> 	   1:벽
> 	   2:청소0
> 	*/
> 
> 	while (true) {
> 		//1.현재 위치를 청소한다.
> 			MAP[x][y] = 2;
> 		
> 
> 		/*
> 			2.3,2.4 네 방향 모두 청소가 이미 되어있거나 벽인 경우
> 			
> 		*/
> 		if (MAP[x + 1][y] != 0 && MAP[x - 1][y] != 0 && MAP[x][y - 1] != 0 && MAP[x][y + 1] != 0) {
> 		
> 			if (MAP[x - dx[dir]][y - dy[dir]] == 1) {
> 				break;
> 			}
> 			else {
> 				x = x - dx[dir];
> 				y = y - dy[dir];
> 			}
> 			
> 		}
> 		else {
> 
> 
> 			dir = (dir + 3) % 4;
> 			//2.1 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
> 			if (MAP[x + dx[dir]][y + dy[dir]] == 0) {
> 				x = x + dx[dir];
> 				y = y + dy[dir];
> 			}
> 			
> 
> 		}
> 	}
> 
> 	int ans = 0;
> 	for (int i = 0; i < n; i++) {
> 
> 		for (int j = 0; j < m; j++) {
> 
> 			if (MAP[i][j] == 2)
> 				ans++;
> 
> 		}
> 	}
> 	cout << ans << "\n";
> 
> 	
> 
> }
> ```
>
> 이와 같은 식으로 해결할 수 있습니다.
>
> https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/Simulation/14503.cpp


















