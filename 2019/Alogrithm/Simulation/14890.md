# 경사로

> **문제분류:Simulation**
>
> **문제번호:14890**

> solution 1.
>
> 문제의 크기: 지도의 크기 N (2 ≤ N ≤ 100), 경사로의 길이L (1 ≤ L ≤ N)
>
> 시간제한: 2초
>
> 
>
> 이 문제는 지나갈 수 있는 길의 개수를 구하는 문제입니다.
>
> 우선 지나갈 수 있는 조건은 다음과 같습니다.
>
> -  모든 칸의 높이가 모두 같아야 한다. 
>
> - 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있어야 한다.
>
>   <경사로를 놓을 수 있는 조건>
>
>   - 사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
>   - 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
>   - 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.
>
>   
>
>   <경사로를 놓을 수 없는 조건>
>
>   - 경사로를 놓은 곳에 또 경사로를 놓는 경우
>   - 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
>   - 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
>   - 경사로를 놓다가 범위를 벗어나는 경우
>
> 
>
> 총 2N의 길에서 경사로를 놓아서 가는 경우 그냥 지나가는 경우를 따져가면서 문제를 풀면 됩니다.
>
> 우선 경우를 따져보면(arr은 길의 높이를 저장한 배열이라고 가정, before 이전, next 다음)
>
> 1. 길의 높이가 같은 경우(arr[before]==arr[next])
>
> 2. 이전 길의 높이가 다음 길의 높이보다 큰 경우(arr[before]>arr[next])
>
>    - 이전 길의 높이와 다음 길의 높이 차는 1이어야 한다.
>
>    - next+L(경사로 길이)<n
>
>    - 경사로가 중복되면 안된다.
>
>      
>
> 3. 이전 길의 높이가 다음 길의 높이보다 작은 경우(arr[before]<arr[next])
>
>    - 이전 길의 높이와 다음 길의 높이 차는 1이어야 한다.
>    - before-L(경사로 길이)+1>=0
>    - 경사로가 중복되면 안된다.
>
>    
>
> 해당 조건에 맞게 코드를 작성하면 문제를해결할 수 있습니다.
>
> https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/Simulation/14890.cpp


















