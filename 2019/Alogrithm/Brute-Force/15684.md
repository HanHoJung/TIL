# 사다리 조작

> **문제분류:Brute force**
>
> **문제번호:15684**

> solution 1.
>
> 문제의 크기: N,M,H(2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)
> 제한시간:2초
>
> 
>
> 문제의 조건
>
> - N(세로선),  M(가로선), H(가로선을 놓을 수 있는 위치의 개수)
> - 가로선의 범위가 (N-1) * H인 이유는 N-1개의 가로와 H개의 세로가 존재하기 때문에 (N-1) *H 개가 존재하게 됩니다.
> - 각 세로선이 게임의 시작점
> - 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다
> - 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.
> - 사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.
>
> 
>
> 우선 가로선을 놓을 수 있는 모든 경우의 수를 세워보면 가로선의 총 개수 2<sup>(N-1)* h</sup>
>
> 가 나오게 된다. 따라서 모든 경우를 구하는 것은 상당히 많은 시간이 소요된다. 그러나 문제의 조건에
>
> 답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다라는 조건이 있기 때문에 
>
> 최대 n의 값 10 h의 값 30  270<sup>3</sup> 만큼만 따져주면 됩니다.
>
> logic 짜기
>
> 1. 입력값 입력받기
>
>    ```c++
>    visit[a][b]//의미는 a번 점선의 위치에서 b번과 b+1 세로선을 연결함을 나타냅니다.
>    ```
>
> 2. 경우의 수 구하기
>
>    - 종료조건 cnt==3인경우
>    - 다음조건 cnt<3인 경우
>
>    ```c++
>    //이 코드가 (n-1) *h 번 돌려주는 코드입니다.
>    /*
>    	visit[i][j - 1] == false && visit[i][j + 1] == false 고려하는 이유는 가로선 양     옆에 연속된 선이 있는지 없는지 확인시켜주는 코드 입니다.
>    */
>    
>    for (int i = row; i <= h; i++) { 
>    		for (int j = 1; j < n; j++) {
>    			if (visit[i][j] == false) {
>    				if (visit[i][j - 1] == false && visit[i][j + 1] == false) {
>    					visit[i][j] = true;
>    					go(i, cnt + 1);
>    					visit[i][j] = false;
>    				}
>    			}
>    		}
>    
>    	}
>    ```
>
> 3. 사다리가 올바른 방향으로 가는지 check
>
>    ```c++
>    bool ladder(void) {
>    
>    	for (int col = 1; col <= n; col++) {
>    		int s = col;
>    		for (int row = 1; row <= h; row++) {
>    			if (visit[row][s]) {
>    				s = s + 1;
>    			}
>    			else if (s > 1 && visit[row][s - 1]) {
>    				s = s - 1;
>    			}
>    		}
>    
>    		if (s != col)
>    			return false;
>    	}
>    
>    	return true;
>    }
>    
>    ```
>
>    
>
> https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/Brute-Force/15684.cpp
>














