# 다음 순열

> **문제분류:Brute force**
>
> **문제번호:10972**

> solution 1.
>
> 문제의 크기:(1<=N<=10,000)
>
> 시간제한: 1초
>
> 1부터 N까지의 순열을 사전순으로 출력
>
>
>
> 이 문제를 브루트 포스 알고리즘을 사용하면
>
> 1단계: 문제의 가능한 경우의 수 구하기
>
> 첫 번째 자리에 n가지 경우
>
> 두 번째 자리에 n-1가지 경우
>
> ...
>
> n 번째 자리에 1가지 경우
>
> n! 경우의 수가 나오게 된다.
>
>
>
> 2단계:가능한 모든 방법을 다 만들어 본다.
>
> 다음 수열을 구하는 방법은
>
> - 종료조건
>
>   - 수열이, 내림차순으로 정렬이 완료된 경우
>
> - 풀이
>
>   - 오름차순을 내림차순으로 최종적으로 변경하는 것이므로 아직 변경되지 않은 오름차순의 index를 찾는다.
>   - arr[index-1]>arr[n] (n:배열의 길이 -1) 배열의 길이의 끝 부터 반복문 조사하여 arr[index-1]보다 큰 값과 swap(arr[index-1], arr[k])
>   - arr[index]부터 배열의 끝까지 순열을 뒤집는다.
>
> - 시간 복잡도는 next_permutation이 반복되는 횟수의 곱인 O(n)의 복잡도를 나타내기 때문에 문제의 시간 제한 안에 풀 수 있다.(1억에 1초로 계산)
>
>
>
> ![permutation](https://vitamindragon.github.io/assets/images/permutation.jpg)
>
> O(n!) **//모든 경우의 수**
>
> 다음 순열을 구하는 시간 복잡도  O(n)**//한 가지 방법을 시도해보는 시간복잡도**
>
> 시간복잡도(n!*n) **//모든 경우의 수 * 한 가지 방법을 시도해보는 시간복잡도**
>
>
>
> 3단계:각각의 방법
>
> 순열을 이용해서 문제 해결
>
>

https://github.com/HanHoJung/Algorithm/tree/master/Algorithm/Brute-Force/10972.cpp












