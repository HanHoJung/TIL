# 맞춰봐

> **문제분류:Brute force**
>
> **문제번호:1248**

> solution 1.
>
> 문제의 크기:   N(N ≤ 10)
>
> 시간제한: 2초
>
> 
>
> 이 문제는 수열의 길이 N을 통해 만들 수 있는 N(N+1)/2 개의 부분합에 대해 , 문자열과 일치하는 수열을 찾는 문제 입니다. 처음 문제를 풀 때 -10부터 10까지 수의 조합을 만들어서 계산할려고 아래와 같은 코드를 작성하였습니다. 21개의 수에 대하여 10자리 수를 만드는 경우는 21<sup>10</sup> 이므로 시간 초과가 나오게 됩니다. 때문에, 백트래킹을 통해 경우의 수를 줄여야 합니다.
>
> ```c++
> void go(int index) {
> 	if (index == n) {
> 		return check();
> 	}
>     
> 	for (int i=-10; i<=10; i++) {
> 		ans[index] = i;
> 		if (go(index+1))
> 	}
> 		
> }
> ```
>
> <경우의 수 줄이기1>
>
> 문제에서, 합이 0보다 크면 **+** 합이 0이면 **0** 합이 0보다 작으면 **-**
>
> 이 조건에 대하여 sign 배열을 초기에 만들어 줄때 아래와 같은 조건에 따라 배열을 만듭니다.
>
> - 합>0 :1
> - 합==0:0
> - 합<0:-1
>
> 그러면 한 함수가 총 21번 돌아야 할것을 10번으로 줄일 수 있습니다.
>
> 
>
> ```c++
> void go(int index) {
> 	if (index == n) {
> 		return check();
> 	}
> 	for (int i=1; i<=10; i++) {
> 		ans[index] = sign[index][index]*i;
> 		if (go(index+1)) 
> 	}
> 		
> }
> ```
>
> 
>
> 아직도 경우의 수가 많기 때문에 줄일 수 있는 방법을 찾아봅시다.
>
> <경우의 수 줄이기2>
>
> 만약, n이 4일때
>
> |      |  0   |  1   |  2   |  3   |
> | :--: | :--: | :--: | :--: | :--: |
> |  0   |  +   |  -   |  0   |  +   |
> |  1   |      |  -   |  +   |  -   |
> |  2   |      |      |  +   |  +   |
> |  3   |      |      |      |  +   |
>
> 각 index 마다 부호가 나올 수 있는 경우와 나올 수 없는 경우를 check해주면 경우의 수를 급격하게 줄일 수 있습니다.

https://github.com/HanHoJung/Algorithm/tree/master/Algorithm/Brute-Force/1248.cpp  














