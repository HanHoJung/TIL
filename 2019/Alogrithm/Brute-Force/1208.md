#  부분집합의 합2

> **문제분류:Brute force**
>
> **문제번호:1208**

> solution 1.
>
> 문제의 크기:   N,M(1≤N≤40, |S|≤1,000,000) 
>
> 시간제한: 1초
>
> 
>
> 첫째 줄에 합이 S가 되는 부분집합의 개수를 출력하는 문제입니다. 이 문제를 하나의 배열을 두고 비트마스크를 구해 문제를 풀게되면 시간초과가 발생하게 됩니다. 그 이유는 2<sup>40</sup> 가지의 경우가 발생하기 때문입니다.
>
> 이 문제를 비트마스크를 이용하여 풀기 위해서는 다음과 같은 방법을 이용하면 됩니다.
>
> <Meet int the Middle>
>
> - n 제한이 20이 넘어가면 비트마스크로 1초안에 문제를 해결하기 어렵습니다. 이때, 사용하는 방법이 Meet in the Middle이라는 방법 입니다.
> - 문제를 절반으로 나누어서, 나누어진 결과를 합치면서 부분집합을 구하는 알고리즘 입니다.
> - 만약, 공집합의 경우를 빼라고 하였을 때는 두 집합이 공집합일 때 합이 0이기 때문에 0인경우를 하나 빼주면 됩니다.
>
> ```
> 배열=[1,2,1,3,2,1], Search=4 , N=6
> 1.배열 절반으로 쪼개기
>    n(전체)
>    m = n/2
>    n = n-m = n-n/2
>    
> 2.A배열, B배열 비트마스크로 부분집합의 합 구하기
> A배열=[1,2,1]=>0,1,2,1,3,2,3,4(부분집합의 합)
> B배열=[3,2,1]=>0,3,2,1,5,4,3,6(부분집합의 합)
> 
> 
> 3.정렬를 진행한다.(정렬을 하는 이유는 같은 수가 중복해서 나올 수 있기 때문에 그것을 계산하기 위해서)
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
> 
> 4.탐색(Search 4)
> L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>               R
>               
> L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>             R       
>             
> L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>           R                   
> =>위 0이 1개, 아래 4가 1개 1*1=1(찾은 후 L과 R 동시이동)
> 
>   L    
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>         R    
> =>위 1이 2개, 아래 3이 2개 2*2=2(찾은 후 L과 R 동시이동) 
> 
>       L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>     R  
> =>위 2가 2개, 아래 2가 1개 2*1=2 
> 
>           L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
>   R    
> =>위 3이 2개, 아래 1이 1개  
> 
>               L
> 0 1 1 2 2 3 3 4
> 0 1 2 3 3 4 5 6
> R 
> =>위 4가 1개, 아래 0이 1개
> ```
>
> 

https://github.com/HanHoJung/Algorithm/tree/master/Algorithm/Brute-Force/1208.cpp  


















