# Hash



[TOC]



## 1. Hash Table

데어터를 저장하는 방식 중에 Table(=MAP=Dictionary Structure)라는 자료구조가 있습니다.

**정의**

- key와 value로 구성되어 있고 key를 통해 data를 조회, 저장, 삭제 할 수 있는 자료구조 입니다.

- 검색하려는 key값을 입력받아서 해쉬함수를 사용하여 반환받은  해쉬코드를 배열의 Index로 환산을 해서

  데이터에 접근하는 방법

  F(key)=>HashCode=>Index=>Value

**특징**

- key를 만드는 수식이 따로 존재합니다.
- key는 데이터를 구분하는 역할을 하기 때문에 unique 해야 합니다.
- key를 만들때 연산을 요구하는 단점이 있습니다. 더불어, 적용범위가 작고 메모리 효율 측면에서 떨어집니다.



cf)

key에 대응대는 데이터가 저장되는 공간을 bucket(Slot이라고 합니다.

bucket의 상태는 다음과 같습니다.

- EMPTY:이 슬롯에는 데이터가 저장된적이 없다.
- DELETED:이 슬롯에는 데이터가 저장된바 있으나 현재는 비워진 상태이다.
- INUSE:이 슬롯에는 현재 유용한 데이터가 저장되어 있다.

cf)

**해시함수**

key 값에 대한 범위를 줄이면서 유일성을 확보하도록 도와주는 함수가 Hash Function(해시함수) 입니다.

![hash function image.png](https://steemitimages.com/DQmUXjW7A8FDbXchu9WYy6LBWskraAviLy7RzYuPfCSp4tH/hash%20function%20image.png)



<좋은 해쉬함수 설계 방법>

- 좋은 해쉬함수 설계란, 테이블의 특정 영역에 데이터가 몰리지 않고 전체적으로 고르게 퍼진 상태를 가지게 하는 것이 좋은 해쉬함수 입니다. 특정 영역에 몰리게 되면 충돌이 발생할 가능성이 높기 때문입니다.

- 또한, key의 일부분을 참조해서 해쉬 값을 만들지 않고, 키 전체를 참조하여 해쉬 값을 만들어야 좋은 해쉬함수라고 할 수 있습니다. 그 이유는 키의 일부분의 데이터 조합보다 키 전체의 조합으로 해쉬를 생성했을때 다양한 값의 생성을 기대할 수 있기 때문입니다.

- 해쉬 함수를 만드는 최적의 방법은 상황에 따라 달라지기 때문에 어떤 방법이 좋다고 할 수 없습니다. 일반적으로 키 전체를 참조하는 방법을 많이 선택하기 때문에 대표적인 해쉬 함수 디자인 방법을 소개하겠습니다.

  - Digit Selection(자릿수 선택)

    키의 특정 위치에서 중복의 비율이 높거나, 아예 공통으로 들어가는 값이 있다면, 이를 제외한 나머지를 가지고 해쉬 값을 생성하는 방법

    

  - Digit Folding(자릿수 폴딩)

    2 7 3 4 1 9 라는 6자리수가 있을 때 삼등분으로 접으면 27 | 34| 19 가 겹치게 된다. 겹치게 된 수를 모두 더하면 80 이라는 결과가 나오게 된다. 이를 해쉬 값으로 하면 6자리의 숫자를 모두 반영하여 얻은 결과라 할 수 있다.



## 2. Collision

데이터가 Hash function을 거치면 유일한 key가 나오게 됩니다. 그러나 해쉬 함수를 거쳤는데 결과가 동일한 키가 나오는 상황이 발생할 수 있습니다. 이 경우를 Collision(충돌)이 발생했다고 합니다.

(키값은 그 경우가 무한한 반면에 해쉬코드는 정수값이여서 유한하기 때문에  정수개 만큼 제공됨 따라서 해쉬코드 값이 중복이 될 수 있습니다.)

ex)

x= 20120003, 20120103

Hash=> hash(x) = x%100

y=3, 3



충돌이 발생했을 때 그 자리를 대신해서 빈 자리를 찾아야 합니다. 빈 자리를 찾는 방법은 다음과 같습니다.

1. **Linear probing(선형 조사법)**

   충돌이 발생했을 때 그 옆자리가 비었는지 살펴보고, 비었을 경우 그 자리에 대신 저장하는 방법 입니다.

   f(k)+1->f(k)+2->f(k)+3... 이동하면서 빈 공간을 찾습니다. 이러한 선형 조사법의 문제는 충돌의 횟수가 증가할 때마다 특정 영역 주위로 데이터가 집중적으로 몰리는 현상(클러스트)이 발생하는 단점이 있습니다.

   이 문제를 해결하기 위해서 f(k)+1<sup>2</sup>->f(k)+2<sup>2</sup>->f(k)+3<sup>2</sup>... 충돌이 발생 횟수마다 n<sup>2</sup> 칸 옆 슬롯을 이동하는 방법을 **이차 조사법**이라고 합니다.

   

2. **Double Hash(이중 해쉬)**

   이차 조사법을 사용해도 해쉬 값 f(k)가 같다면 k가, 다르더라도 일정한 순서로 빈 슬롯을 찾게 됩니다. 선형조사법 보다는 클러스터 현상이 낮지만 접근이 진행되는 슬롯을 중심으로 클러스터 현상이 발생할 확률은 여전히 높게 됩니다. 따라서, 빈 공간을 선택하는 방식을 임의적으로 만드는 것이 이중 해쉬 방법 입니다.

   이중 해쉬 방법은 다음과 같습니다.

   - 두 개의 해시 함수를 만듭니다.
     - 1차 해쉬함수:키를 근거로 저장 위치를 결정
     - 2차 해쉬함수:충돌 발생시 몇 칸 뒤를 살필지 결정

   

   ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/HASHTB12.svg/1024px-HASHTB12.svg.png)

   위와 같은 방법을 open addressing method(열린 어드레싱 방법)이라 합니다.

   - 충돌이 발생했을 때 다른 자리에 저장하는 방식

   

   

   3.**Chaining(체이닝)**

      체이닝 방식에서는 closed addressing method(닫힌 어드레싱 방법)을 사용합니다. 

   - 충돌이 발생했을 때 역시, 자기 자신의 자리에 데이터를 저장한다.
   - 하나의 주소 공간에 여러개의 데이터를 저장하는 방식으로서 한 주소 영역에 여러개의 데이터를 저장할 수 있는 방법으로 연결리스트 또는 배열을 사용한다. 보통 연결리스트로 구현을 한다.
   - 체이닝은 슬롯을 생서하여 연결 리스트 모델로 연결해나가는 방식으로 충돌 문제를 해결할 수 있습니다.

   

  ![Hash table: chaining illustration](http://www.algolist.net/img/hash-table-chaining.png)







