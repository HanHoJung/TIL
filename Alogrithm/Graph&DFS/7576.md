# 토마토

> **문제분류:그래프와 bfs**
>
> **문제번호:7576**

> solution 1.
>
> 문제의 크기:M(가로) N(세로)  2 ≤ M,N ≤ 1,000
> 문제 조건:  토마토가 모두 익는 최소 일 수 출력
>
> ​                    저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력
>
> ​                    토마토가 모두 익지는 못하는 상황이면 -1을 출력
>
> 제한시간:1초
>
>
>
> 이 문제는 N*M 크기의 배열안에 있는 토마토를 익히는데 걸리는 최소 일수를 출력하는 문제입니다.
>
> 이 문제 역시 dfs를 통하여 문제를 해결할 수 있습니다.
>
>
>
> 토마토 상태
>
> 1.익은 토마토(1)
>
> 2.익지 않은 토마토(0)
>
>
>
> 보관 1일 후
>
> 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토는
> 익은 토마토에 영향을 받아 익게 된다.(방향은 상,하,좌,우)
>
>
>
> **1.최소비용 문제이어야 한다.**
>
> N*M 크기에 통 안에 시간이 지날 수 록 토마토가 모두 익는 최소 일수를 구하는 문제입니다.
>
>
>
> **2.간선의 가중치가 1이어야 한다.**
>
> 정점은 토마토(0또는 1)를 의미하고
>
> 간선은 토마토와 토마토의 연결이라고 정의하자
>
> 하루가 지날때 토마토의 확장 범위는 1씩이다. 이는 가중치가 1을 의미한다.
>
>
>
> **3.정점과 간선의 개수가 작아야 한다.**
>
> 1000*1000 = 1000000
>
> 100만개 정도면 BFS로 최소비용을 구할 수 있습니다.
>
>
>
> ```C++
> 
> 		for (int i = 0; i < 4; i++) {
> 
> 			int new_x = x + dx[i];
> 			int new_y = y + dy[i];
> 
> 			if (new_x<0 || new_x>=n || new_y<0 || new_y>=m)
> 				continue;
> 
> 			if (edge[new_x][new_y] ==0 && check[new_x][new_y] == false) {
> 				check[new_x][new_y] = true;
> 				dist[new_x][new_y] = dist[x][y] + 1;
> 				edge[new_x][new_y] = dist[new_x][new_y];
> 				q.push(make_pair(new_x, new_y));
> 			}
> 		}
> 
> ```
>
> edge의 값을 dist(일 수) 값으로 변경해준다.
>
> 그 결과, edge 값 중 가장 큰 값이 1이라면 처음부터 모두 토마토가 익혀진 경우를 의미하기 때문에 0을 출력해준다. 또한, edge 값 중 하나라도 0이 존재한다면 모든 토마토가 익혀지지 않는 경우를 의미함으로 1을 출력한다. 위에 두 경우가 아니라면 edge 배열 중 가장 큰 값이 바로 최소 일수가 된다.

https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/7576.cpp












