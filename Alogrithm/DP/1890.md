# 점프

> **문제분류:다이나믹 프로그래밍**
>
> **문제번호:1890**

> solution 1.
>
> 문제의 크기:  게임 판의 크기 N (4 ≤ N ≤ 100)
>
> 제한시간:1초
>
> 
>
> 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수
>
> <문제의 조건>
>
> - 보드 판,N * N (4 ≤ N ≤ 100)
>
>   - 각 칸에 쓰여있는 수는 현재 칸에서 갈 수 있는 거리
>
> - 이동방향
>
>   - 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재
>
>   - 0은 더 이상 진행을 막는 종착점
>
>   - 한 번 점프를 할 때, 방향을 바꾸면 안됨
>
>     
>
> `dp[i][j]` 는 i,j로 이동할 수 있는 방법의 수를 의미합니다.
>
> <방법1>
>
> - 오른쪽으로 이동하는 경우
>
>   - 좌표(i, j)=>좌표(i1, j1)으로 이동하는 방법은 다음과 같습니다.
>
>   - j의 조건(0<=j<j1)................exp1
>
>   - `arr[i1][j]+j==j1` 일때
>
>     `dp[i1][j1]+=dp[i1][j]`
>
>     
>
> - 아래쪽으로 이동하는 경우
>
>   - 좌표(i,j)=>좌표(i1, j1)으로 이동하는 방법은 다음과 같습니다.
>
>   - i의 조건(0<=i<i1).............exp2
>
>   - `arr[i][j1]+i == i1` 일때
>
>     `dp[i1][j1]+=dp[i][j1]`
>
>   
>
> 시간복잡도는 다음과 같습니다. 모든 칸을 채우는데 n<sup>2</sup>의 시간이 걸리고 하나의 dp를 구하기 위해서 n의 시간이 걸리기 때문에 시간복잡도는 O(n<sup>3</sup>)이 도출됩니다.
>
> 그러나 이렇게 풀게 되면 exp1, exp2 예 처럼 `arr[i1][j]+j==j1` 과 `arr[i1][j]+j==j1` 인 경우가 모두 성립하는 경우는 없기때문에(j조건 또는 i조건에 따라) 중복검사라는 단점이 있습니다.
>
> 
>
> <방법2>
>
> - 오른쪽으로 이동하는 경우
>
>   - 좌표(i, j)=>좌표(i,j+1)으로 이동하는 방법은 다음과 같습니다.
>
>   - `arr[i][j]+j<n` 일때
>
>     `dp[i][j+arr[i][j]]+=dp[i][j]`
>
>     
>
> - 아래쪽으로 이동하는 경우
>
>   - 좌표(i,j)=>좌표(i+1,j)으로 이동하는 방법은 다음과 같습니다.
>
>   - `arr[i][j]+i<n` 일때
>
>     `dp[i+arr[i][j]][j]+=dp[i][j]`

https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/DP/1890.cpp








