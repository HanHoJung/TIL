# 팰린드롬?

> **문제분류:다이나믹 프로그래밍**
>
> **문제번호:10942**
>
> **제한시간:0.5초**

> solution 1.
>
> 이 문제는  어떠한 연속한 수열이 팰린드롬인지 아닌지 구하는 문제입니다.
>
> 우선, 팰린드롬 수열이란 앞에서 읽거나 뒤에서 읽어도 같은 수열을 나타냅니다.
>
> 팰린드롬 수인지 아닌지 구하는 방법은 다음과 같습니다.
>
> 1. 문자열과 뒤집은 문자열이 같은지 확인하는 것 입니다.(문자열 길이는 n)
>
>    - 문자열을 뒤집는데 O(n)의 시간이 걸림
>
>    - 문자열과 뒤집은 문자열 비교 O(n)의 시간이 걸림
>
>    - 종합적으로 O(n)의 시간이 걸림
>
>      
>
> 2. 문자열  앞 뒤를 비교하는 방법을 이용(문자열 길이는 n)
>
>    - str[i],str[n-i-1]  (0<=i<n/2)//
>
> 
>
> - 수열의 크기 N (1 ≤ N ≤ 2,000)
>
> - 질문의 개수 M (1 ≤ M ≤ 1,000,000)
>
> 총 시간복잡도가 ( N * M)의 시간이 걸리게 된다. 그러나 이와 같은 방법으로 풀게되면 시간초과가 나오기 때문에 다른 방식으로 풀어야 한다.
>
> 
>
> 이 문제를 다이나믹으로 해결할 수 있습니다. 
>
> 우선, 점화식의 정의는 다음과 같습니다. 
>
> `D[i][j]` i부터 j까지의 수열이 팰린드롬인지 아닌지를 나타냅니다.
>
> - 팰린드롬이면 1
> - 팰린드롬이 아니면  0
>
> 1. 길이가 1인 문자열은 무조건 팰린드롬이기 때문에 `d[i][i]`==1
>
> 2. 길이가 2인 문자열은 `d[i][i+1]`==1/0의 값을 가지고 
>
>    true가 되기 위해서는 a[i]==a[i+1] 이어야 합니다.
>
> 3. A[i] ~ A[j]가 팰린드롬이 되기 위해서는, A[i]==A[j] 이어야 하고, A[i+1]~A[j-1]이 팰린드롬이어야 한다.
>
>    `dp[i][j]=1(A[i]==A[j] && dp[i+1][j-1]==1)`

https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/DP/10942.cpp  //top-down

https://github.com/HanHoJung/Algorithm/blob/master/Algorithm/DP/10942(1).cpp  //bottom-down










