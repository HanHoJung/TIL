# Chapter01 웹 브라우저가 메시지를 만든다.

[TOC]

## STORY 01 HTTP 리퀘스트 메시지를 작성한다.

> 브라우저와 URL의 관계(1)

- 브라우저는 웹 서버, FTP 서버, 메일 서버를 접근하는 클라이언트 기능을 수행한다.

- 이때, 사용자가 URL을 통해 브라우저에게 접근 방법을 알려주게 된다.

  ```
  접근방법://웹 서버명/elfprxhflaud/파일명
  (http,ftp,mail)
  
  HTTP 프로토콜로 웹 서버에 엑세스 하는 경우
  https://www.naver.com/index.html
           (웹 서버명)    (자원)
  FTP 프로토콜로 파일을 다운로드 하거나 업로는 하는 경우
  ftp://ftp.cyber.co.kr/dir/index.html
  
  클라이언트 PC자체의 파일에서 데이터를 읽어오는 경우
  file://localhost/c:/download/file.zip
  
  ```


> 브라우저의 URL의 관계(2)

- 사용자 => URL 제출

- 브라우저=> URL 해독(어디에 액세스해야 할지 결정)

- 브라우저=> HTTP Request 메시지 작성 및 전송

- 서버=>Request 메시지 속에서 "무엇을" , "어떻게 해서"를 판단한 후 동작

- 서버=>해당 처리후 HTTP Response 메시지 작성 및 전송


> HTTP의 기본 개념

HTTP 응답 코드 종류 && HTTP 메소드 종류

CGI의 개념

[출처]

http://gyrfalcon.tistory.com/entry/HTTP-%EC%9D%91%EB%8B%B5-%EC%BD%94%EB%93%9C-%EC%A2%85%EB%A5%98-HTTP-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A2%85%EB%A5%98

https://okky.kr/article/433046?note=1352766

- Request메시지

  > ''무엇을"(URI, 파일의 이름 또는 CGI 프로그램)
  >
  > "어떻게 해서"(메소드, 웹서버에서 어떤 동작을 원하는지)

  ````
  (a)
  <메소드><공백><URI><공백><HTTP 버전>   //첫번째 행을 리퀘스트 라인
  <필드명>:<필드값>                    //메시지 헤더
  ...                                //한 행에 한 개의 헤더 필드, 공백까지가 헤더 부분
  <공백 행>                
  <메시지 본문>                       //POST 전송시 데이터 내용이 담긴다.
  ````


- Response 메시지

  > ''무엇을"(URI, 파일의 이름 또는 CGI 프로그램)
  >
  > "어떻게 해서"(메소드, 웹서버에서 어떤 동작을 원하는지)

  ````
  (b)
  <HTTP 버전><공백><스테이터스 코드><공백><응답 문구>//응답문구는 Status code 내용의 짧은 설명문
  <필드명>:<필드값>                    //메시지 헤더
  ...                                //한 행에 한 개의 헤더 필드, 공백까지가 헤더 부분
  <공백 행>                
  <메시지 본문>          //클라이언트에게 송신하는 데이터(바이너리 데이터)
                         -파일에서 읽은 데이터
                         -CGI 애플리케이션이 출력한 데이터
                         
  ````



- status code

  - 코드값 (첫 번째 값 개요, 두번째와 서번째 값은 상세한 상황)

    > 1xx:처리의 경과 상황 등을 통지
    >
    > 2xx:정상 종료
    >
    > 3xx:무언가 다른 조치가 필요함
    >
    > 4xx:클라이언트 측 오류
    >
    > 5xx:서버측 오류



## STORY 02 웹서버의 IP 주소를 DNS 서버에 조회한다.

   1.브라우저:HTTP 메시지 작성  

   2.운영체제에게 송신 요청

3. 웹서버에 전송됨



> IP 주소의 기본

IP주소

- IP 주소는 32 비트의 디지털 데이터
- 1byte씩으로 점으로 구분, 10진수로 표현
- IP주소의 호스트 주소가 모두 0: 서브넷 자체(네트워크 번호)
- IP주소의 호스트 주소가 모두 1: 브로드캐스트(서브넷에 있는 기기 전체에 패킷을 보내는것을 의미)



넷마스크

- 넷마스크를 통해, 네트워크 번호와 호스트 번호로 구별

```
(A)IP 주소 표기 방법 1
10.11.12.13

(B)IP 주소 표기 방법 2
10.11.12.13(ip 주소 본체) /255.255.255.0(네트워크 마스크)

(C)IP 주소 표기 방법 3
10.11.12.13(ip 주소 본체) /24(넷마스크)



(D)서브넷을 나타내는 주소
10.11.12.0/24

(E)서브넷의 브로드캐스트를 나타내는 주소
10.11.12.255/24


IP주소         10.1.2.3
넷마스크       255.255.255.0

네트워크 번호 10.1.2
호스트 번호          3        

```



cf)

* 브라우저는 네트워크로 송출하는 기능이 없기 때문에 운영체제에 요청

* 서브넷: '허브'' 몇 대가 pc에 접속된 것을 의미한다. 이것의 하나의 단위를 서브넷이라 정의한다.

  또한, 이러한 서브넷들이 라우터에 연결되면 이것이 종합적으로 모이면 네트워크 전체가 완성된다. 

* 00동(서브넷==네트워크 번호)  00번지(호스트번호==컴퓨터)

* 패킷이 전달되는 과정

  - PC에서 목적지에게 패킷을 보냄
  - 허브는 이 패킷을 라우터까지 전송시킴
  - 라우터는 다음 라우터를 판단하고 해당 패킷을 보냄 
  - 해당 패킷은 허브를 통해 라우터가 전송받음



> 도메인 명과 IP 주소를 구분하여 사용하는 이유

- IP 주소 보다 도메인명을 이용하여 통신하는것이 직관적이고 이해하기 쉬울 수 있다 .

  그러나 실행 효율 측면에서는 IP 주소는 4byte 데이터 개수만 필요한 반면에 도메인 주소로 통신할 경우

  문자이기 때문에 많은 Byte가 필요하고 라우터에 부하에 여향을 미친다. 


>  Socket 라이브러리가 IP 주소를 찾는 기능을 제공한다.

- DNS 클라이언트를 DNS resolver(resolver) 라고 정의한다.
- DNS 클라이언트가 DNS 서버로 부터 IP주소를 알아오는 작업을 name resolution이라 한다. 
- resolver는 Socket 라이브러리의 부품(네트워크 통신 기능에 대한 기능 모임집)



> 리졸버를 이용하여 DNS서버를 조회한다.

```c++
메모리 영역 = gethostbyname("www.naver.com");=> DNS 서버에 요청을 보낸다.
      //리졸버의 프로그램 명
/*
- gethostbyname 함수를 통해 얻어진 ip 주소를 통해 브라우저는 HTTP 리퀘스트 메시지와 함께 OS에 건   네주어 송신을 의뢰한다.
*/
```

cf)

프로토콜 스택(TCP/IP 소프트웨어==프로토콜 드라이버)

- OS에 내부에 내장된 네트워크 제어용 소프트웨어



(참고) http://forum.falinux.com/zbxe/index.php?document_srl=518686&mid=C_LIB



> 리졸버 내부의 작동

```
//애플리케이션 프로그램(웹 브라우저)
  -메모리 영역 = gethostbyname("www.naver.com");
  

//Socket
  gethostbyname{
    -DNS 서버에 보내진 조회 메시지 작성 
    -조회 메시지를 DNS 서버에 보냄 
    
    -DNS 서버에서 보낸 응답 메시지 수신
    응답 메시지에서 ip주소를 추출한다.
    애플리케이션으로 돌아간다.
 }

//OS내부의 프로토콜 스택
   -UDP 메시지 송신{
       송신 동작 
   }
   
   -UDP 메시지 수신{
       수신 동작
   }
   
   
//LAN 어댑터

//DNS 서버
```

