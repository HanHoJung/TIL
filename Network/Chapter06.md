# Chapter06 웹 서버에 도착하여 응답 데이터가 웹 브라우저로 돌아간다.

[TOC]

이전 장에서는, 클라이언트에서 보낸 패킷이 서버로 통과하는 과정을 탐험 해보겠습니다.



## STORY 01 서버의 개요

> 서버 애플리케이션의 구조

서버는 동시에 복수의 클라이언트와 통신 동작을 수행 합니다. **하나의 프로그램**으로 여러 클라이언트를 처리하는것은 어렵습니다. 그 이유는 클라이언트 마다 어디까지 대화가 진행되었는지를 모두 파악해야 하기 때문입니다.

따라서, 서버는 클라이언트가 접속할 때마다 새로 서버 프로그램을 작동하여 **서버 애플리케이션이 클라이언트와 1 대 1로 대화하는 방법**을 주로 사용합니다.



(a)접속을 기다리는 부분

- 서버 프로그램을 작동해서 설정 파일 읽기 등의 초기화 작업 수행
- 접속 동작을 기다리며 쉬는 상태

(b)클라이언트와 대화하는 부분





![](./img/final.PNG)

이 방식이 가능한 이유는 서버 OS는 멀티 태스크 또는 멀티스레드 기능에 의해 다수의 프로그램을 동시에 함께 작동할 수 있는 성질을 이용한 방식 입니다.

cf)

멀티 태스크

- 복수의 태스크(프로그램)를 동시에 실행하는 것 입니다. 하나의 프로세서는 어떤 시점에서 하나의 태스크만 실행하지만 단시간 안에 태스크를 전환하면서 실행하므로 사용자는 동시에 실행하는 것처럼 느껴지는 방식입니다.
- 멀티 프로세스라고도 부름



멀티 스레드

- 멀티 태스크와 같이 복수의 스레드를 동시에 함께 실행하는 기능
- 차이점은 OS 내부적으로 멀티 태스크는 하나 하나 별도의 프로그램으로 취급되지만, 스레드는 한 개의 프로그램 속을 몇 개의 부분으로 나눈것으로 취급됨



> 클라이언트와 서버의 통신

클라이언트 측

1. 소켓을 만듭니다.(소켓 작성 단계)
2. 서버측의 소켓과 파이프로 연결합니다.(접속 단계)
3. 데이터를 송·수신 합니다.(송·수신 단계)
4. 파이프를 분리하고 소켓을 말소합니다.(연결 끊기 단계)



서버 측

1. 소켓을 만듭니다.(소켓 작성 단계)
2. 1 소켓을 접속 대기 상태로 만듭니다.(접속 대기 상태)

2. 2  접속을 접수합니다.(접속 접수 단계)
3. 데이터를 송·수신합니다.(송·수신 단계)
4. 파이프를 분리하고 소켓을 말소합니다.(연결 끊기 단계)



![](./img/final2.PNG)

cf)

bind함수는 지정한 포트번호를 소켓에 기록하는 작업을 수행합니다.

listen함수는 소켓에 접속하기를 기다리는 상태라는 제어 정보를 기록합니다.

=>이 두개의 함수가 호출되면 서버 측의 2.1 동작이 완료 됩니다.

accept 시점, 즉 접속을 접수하는 부분에서는 서버 애플리케이션을 기동한 후 즉시 실행되므로 아직 클라이언트의 접속 패킷이 도착하지 않았을 것입니다.

**접속 패킷이 도착하면,**

1.  접속 대기의 소켓을 복사하여 새로운 소켓을 만듭니다.
2.  새 소켓에 접속 상대의 정보와 제어정보를 기록합니다.
3.  1과 2의 절차가 끝나면 클라이언트 소켓과 서버의 소켓이 연결된 상태가 됩니다.

![](./img/final3.PNG)

4. 클라이언트와 접속하는 부분(b) 부분을 실행시킵니다.



위에서 보면, 

- 접속대기 소켓을 복사하여 새 소켓을 만든다.
- 새 소켓을 클라이언트측의 소켓과 접속한 후 원래 소켓은 그대로 접속 대기 상태인 채로 둡니다.

클라이언트 접속시 접속 대기 소켓을 복사해서 쓰는 이유는 다음과 같습니다.

접속 대기 소켓을 그대로 사용하게 되면 서버에서는 더 이상 접속대기의 소켓이 없기 때문에 다음 클라이언트는 접속하기 곤란하게 됩니다. 따라서 이러한 이유 때문에 새 소켓을 만들고 여기에 클라이언트가 접속하게 됩니다.

또한, 새로운 소켓을 만들 때의 포트 번호도 요점이 됩니다.

보통, 포트 번호는 소켓을 식별하기 위해 사용됩니다. 그러나 서버측에서는 소켓마다 다른 값을 할당해야 한다는 개념을 따르기 어렵습니다. (웹의 경우, 클라이언트는 80으로 접속한다고 정해져있음) 따라서 새로 만든 소켓도 접속 대기 소켓과 같은 포트 번호를 할당 해야 합니다.

이렇게 되면 포트번호는 소켓을 지정하기 위한 번호 입니다. 그런데  같은 번호를 여러개 할당한 소켓이 존재한다면 이는 어떻게 식별해야 될까라는 문제가 발생합니다.

이 문제는 다음과 같이 해결할 수 있습니다.

- 클라이언트측의 IP주소
- 클라이언트측의 포트 번호
- 서버측의 IP 주소
- 서버측의 포트 번호



**클라이언트측의 IP주소, 클라이언트측의 포트 번호**

서버 측의 소켓에서는 같은 포트 번호를 가진 여러 개의 소켓이 존재합니다. 그러나 클리언트 측의 소켓은 모두 다른 포트 번호를 할당해서 사용합니다. 그러나 이 규칙의 클라이언트 내부에서만 정해지지 다른 클라이언트 포트와 같을 수 도 있습니다. 따라서 클라이언트 IP 주소도 판단 근거에 추가하게 됩니다.

ex)

198.18.203.153/1025

198.18.203.86/1025 

![](./img/final4.PNG)