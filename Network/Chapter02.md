# Chapter02 TCP/IP의 데이터를 전기 신호로 만들어 보낸다.

[TOC]

## STORY 01 소켓을 작성한다.

![protocolStack](D:./Img/protocolStack.PNG) 

> 프로토콜 스택의 내부 구성

- 프로토콜 스택이란 운영체제에 내장되어 있는 네트워크 제어용 SW 입니다.

- 운영체제 계층의 TCP 또는 UDP 프로토콜을 사용하여 데이터 송·수신을 합니다.

  보통, TCP는 브라우저 메일 등의 일반적인 애플리케이션의 데이터 송·수신할 경우 많이 쓰입니다.

   UDP는 조회 같은 짧은 제어용 데이터를 송·수신할 경우에 사용됩니다.

- IP 프로토콜은 **패킷 송·수신 동작을 제어**하는데 사용하는 프로토콜 입니다.

  ICMP는 패킷을 운반할 때, **발생하는 오류 및 제어용 메시지**를 통지할 때 사용됩니다.

  ARP는 IP 주소에 대응되는 이더넷의 **MAC 주소**를 알아볼 때 사용됩니다.

- LAN 드라이버는 LAN 어댑터의 하드웨어를 제어합니다.

- LAN 어댑터는 케이블에 데이터를 송·수신을 담당합니다.



> 소켓(통신 제어 정보)

- 프로토콜 스택은 데이터의 송·수신 및 제어 하기 위한 정보를 소켓에 저장 합니다.

  대표적인 정보로는

  - 상대의 IP 주소
  - PORT 번호
  - 통신 동작의 진행 상태

  위 와 같은 정보를 저장하고 그 외 부가적인 정보도 소켓에 저장되어 있습니다.

- 프로토콜 스택은 제어정보를 참조하면서 동작합니다.

  ex)

  1. 데이터 송신 시 소켓의 IP와 PORT 번호를 보고 데이터를 송신합니다.

  2. 데이터를 송신 한 후 일정시간 동안 응답이 오지 않으면 송신 동작을 재 실행합니다.

     이때, 송신 후, 어느 정도 시간이 지난지를 소켓에 저장해놓고 재전송을 결정합니다.


>socket 함수를 호출했을 때의 동작

![socket2](./Img/socket2.PNG)

- 브라우저가 socket, connect 함수를 호출하였을때 프로토콜 스택의 움직임은 다음과 같다.

  - **socket함수**를 통**해 소켓 생성을 의뢰하**면 프로토콜 스택은 하나의 **소켓을 메모리에 생성** 합니다.

    소켓의 처음 생성하는 작업은 차후에 제어 정보를 저장할 그릇을 만드는 과정 입니다. 때문에, 초기에 

    아무 정보가 없어서 쓰임이 없더라도 미래에 쓰임을 위해 준비하는 단계 입니다.

    소켓이 만들어지고 소켓을 식별하는 **디스크립터 번호**를  애플리케이션에게 알려줍니다.




## STORY 02 서버에 접속한다.

> 접속(준비)의 의미

1. 애플리케이션 계층에서, 서버의 IP주소나 PORT 번호를 프로토콜 스택에 알리는 동작을 의미한다.

2. 서버는 클라이언트가 접속할 때까지 상대측의 IP주소와 PORT 번호를 알 수 없다. 때문에, 클라이언트가 서버측에게 통신 동작의 개시를 전달하는것도 접속의 의미이다.

3. 통신 상대와 송·수신 제어정보(IP, PORT번호 등)를 주고 받고 해당 정보를 소켓에 저장한다. 

4. 데이터를 송·수신  동작을 할때 데이터를 일시적으로 저장하는 버퍼 메모리가 필요하다. 이 메모리 확보하는 동작도 접속의 의미이다.




>제어 정보

제어정보 종류(제어정보는 접속 동작, 데이터 송·수신, 연결 끊기 모든 동작에 필요한 정보 입니다.)

- 헤더에 기록되는 정보

- 소켓(프로토콜 스택의 메모리 영역)에 기록되는 정보



  ![img](http://www.ktword.co.kr/img_data/1889_1.JPG)

  ​                                                                  <TCP 헤더>

cf)이더넷헤더(=MAC헤더)



**(a) 데이터를 저장한 패킷**

![](D:./Img/packet.PNG)

**(b) 제어 정보만 있는 패킷**

접속 동작에서는 아직 데이터 송수신이 없기 때문에 패킷에 데이터 부분이 없다.

![packet2](D:/TIL/Network/Img/packet2.PNG)



>접속 동작

**STEP01**

connect(디스크립터, 서버측 IP 주소와 port 번호,...) 호출(socket라이브러리=>프로토콜 스택의 TCP 담당부분)

**STEP02**

**클라이언트 측,** 프로토콜 스택의 TCP 담당 부분은 **서버 측,** 프로토콜 스택의 TCP 담당 부분과 제어 정보를 주고 받습니다.

<STEP02의 단계>

​    <CLIENT>

1. 데이터 송·수신 동작의 시작을 나타내는 **제어 정보를 기록한 헤더**를 만듭니다.

   이때 제어정보는 다양한 항목이 있지만, 이 단계의 핵심은 **클라이언트**와 **서버**의 **포트번호** 입니다.

   이를 통해, 클라이언트의 소켓과 서버의 소켓을 지정할 수 있습니다. 더불어, **컨트롤 비트 SYN**이라는 비트를 1로 만듭니다.(그 외에도, 시퀸스 번호와 윈도우에 적정 값을 설정합니다.)

   **=>TCP 헤더 만들기, 클라이언트와 서버의 각각의 소켓 지정하기**

2. IP 계층에 TCP 헤더 송신 의뢰하기(접속 단계 이기 때문에 패킷에 헤더만 있음)

3. 네트워크를 거쳐 서버의 IP 계층 까지 전송되면 이것을 서버의 TCP 계층에 전달 합니다.

   <SERVER>

4. 서버측 TCP 계층은 헤더 정보를 분석하면 **송신측(클라이언트) 포트 번호** **수신측(서버측) 포트 번호** 등의 제어 정보를 추출할 수 있습니다. 알아낸 정보를 통해서 수신측 포트 번호에 해당되는 소켓을 찾고 그 소켓에 제어 정보를 저장합니다. 더불어 서버는 **접속 진행중** 이라는 상태(6장에서 그 의미 설명)가 됩니다.

5. 서버측 역시, 제어 정보를 기록한 헤더(송신처·수신처 포트번호 , 컨트롤 비트 SYN, ACK 1로 설정 등)를 만듭니다.

6. 서버측 IP 계층에 TCP 헤더 송신 의뢰하기



 <CLIENT>

7. 클라이언트 IP 담당 부분을 경유하여 TCP 계층에 도착합니다.

8. TCP 헤더를 조사하여 서버측의 접속 동작이 성공했는지 여부를 조사합니다.

   조사 방법은 SYN 비트가 1이면 접속 성공을 의미 합니다.  그 이후 클라이언트 해당 소켓에 제어정보(포트번호, 서버 IP 주소, 접속 완료 정보 등)을 저장합니다.

9. 끝으로, 서버가 응답을 받을 것을 알릴때 ACK 비트를 1로 만들어서 보낸것 처럼 클라이언트는 ACK번호를 1로 만든 TCP 헤더를 반송합니다. 



=>STEP02의 절차가 끝나면, close 호출을 할 때 동안 해당 수신측과 송신측은 연결을 유지 합니다.

​     이러한 작업 거친후 상태를 소켓이 연결된 상태  **커넥션(세션)**이 이루어 졌다고 말합니다.

